

# This file was *autogenerated* from the file examples.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_37 = Integer(37); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_12 = Integer(12); _sage_const_26 = Integer(26); _sage_const_10001 = Integer(10001); _sage_const_9 = Integer(9); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_80 = Integer(80); _sage_const_1 = Integer(1); _sage_const_56 = Integer(56); _sage_const_918 = Integer(918); _sage_const_3348 = Integer(3348); _sage_const_132 = Integer(132); _sage_const_72 = Integer(72); _sage_const_688 = Integer(688); _sage_const_3344 = Integer(3344); _sage_const_448 = Integer(448); _sage_const_432 = Integer(432); _sage_const_252 = Integer(252); _sage_const_1512 = Integer(1512); _sage_const_54 = Integer(54); _sage_const_18 = Integer(18); _sage_const_3067999686071442 = Integer(3067999686071442); _sage_const_5303042246606904 = Integer(5303042246606904); _sage_const_62 = Integer(62); _sage_const_22 = Integer(22); _sage_const_192 = Integer(192); _sage_const_48 = Integer(48); _sage_const_30 = Integer(30); _sage_const_158 = Integer(158); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_36 = Integer(36); _sage_const_102 = Integer(102); _sage_const_85 = Integer(85); _sage_const_15 = Integer(15); _sage_const_70 = Integer(70); _sage_const_31 = Integer(31); _sage_const_44 = Integer(44); _sage_const_94 = Integer(94); _sage_const_106 = Integer(106)# examples.sage: code to compute the examples in the paper "Black Box
#  Galois Representations" by Argaez and Cremona

#######################################################################
#
# Copyright 2018 John Cremona
#
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License
# along with this file; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#
#######################################################################

#
# The files KSp.py, C2C3S3.py and T0T1T2.py should be available for
# import (e.g. they should be in the same directory as this).  Start
# Sage from the command line, type the command
#
# %runfile examples.sage
#
# and then follow the instructions.
#

print("To run the examples, type example1() or example2() or example3() at the Sage prompt")

from C2C3S3 import (C3_extensions, S3_extensions)
from T0T1T2 import (get_T0, get_T2, BlackBox_from_elliptic_curve, BB_trace, BB_det, BB_t0, BB_t1, BB_t2, algo6, algo63, algo64)
from KSp import Support

# The following line means that class groups, etc, are computed
# non-rigorously (assuming GRH) which makes everything run faster.

proof.number_field(False)

def example1(shortcut=True, allcurves=False):
    print("\nExample 1 from page 12:")
    K = QQ
    S = [_sage_const_2 ,_sage_const_37 ]
    print("K = {}".format(K))
    print("S = {}".format(S))
    C3s = C3_extensions(K,S)
    print("For K = {} and S = {}, the C3 extension(s) of K unramified outside S are {}".format(K,S,C3s))
    # It takes a couple of seconds to find this cubics, so here we allow a shortcut
    if shortcut:
        x = polygen(QQ)
        S3s = [x**_sage_const_3  - _sage_const_4 *x - _sage_const_2 , x**_sage_const_3  - x**_sage_const_2  - _sage_const_12 *x + _sage_const_26 ]
    else:
        S3s = S3_extensions(K,S)
    print("  and the S3 extension(s) of K unramified outside S are {}".format(S3s))
    F = C3s + S3s
    print("Hence we may take F = {}".format(F))
    flist, T0, vlist = get_T0(K,S,F)
    print("A distinguishing set for F is T0={}".format(T0))
    print("The associated lambda vectors are")
    for f,v in zip(F,vlist): print("lambda={} for f={}".format(v,f))

    print("\nExample 1 (continued) from page 14:")
    if CremonaDatabase().largest_conductor() < _sage_const_10001 :
        print("Since you do not have the optional large Cremona database of elliptic curves installed,")
        print("instead of all 156 isogeny classes of elliptic curves of conductor 2^a*37^b, you will only see 57")
    conductors = [_sage_const_2 **a*_sage_const_37 **b for a in range(_sage_const_9 ) for b in range(_sage_const_3 )]
    # uncomment the following line to simulate not having the large database
    #conductors = [N for N in conductors if N<10000]
    curves = cremona_optimal_curves(conductors)
    print("There are {} isogeny classes of elliptic curves with good reduction outside {}".format(len(list(curves)),S))
    # after counting we must recreate the iterator
    curves = cremona_optimal_curves(conductors)
    divpols = dict([(f,[]) for f in F+["reducible"]])
    # For each curve compute its lambda vector and hence determine residual reducibility or polynomial:
    for E in curves:
        label = E.label()
        BB = BlackBox_from_elliptic_curve(E)
        t0 = BB_t0(BB)
        lam = [t0(p) for p in T0]
        #print("{} has lambda={}".format(label,lam))
        if lam==[_sage_const_0 ,_sage_const_0 ]:
            #print("{}: reducible".format(label))
            divpols["reducible"].append(label)
        else:
            f = F[vlist.index(lam)]
            divpols[f].append(label)
            #print("{}: irreducible, {}".format(label,f))

    for f in F:
        # If the large database is not available, one of the possible cubics does not occur
        if f in divpols:
            print("{} classes have irreducible mod-2 Galois representation with splitting field polynomial {}".format(len(divpols[f]),f))
        else:
            print("No classes have irreducible mod-2 Galois representation with splitting field polynomial {}".format(f))
    nreds = len(divpols["reducible"])
    print("{} classes have reducible mod-2 Galois representation".format(nreds))
    #reducible_curves = [EllipticCurve(lab) for lab in divpols["reducible"]]

    print("\nExample 1 (continued) from page 22.  Note that the indexing set here is {}:".format(range(_sage_const_3 )))
    KS2_basis = K.selmer_group(S,_sage_const_2 )
    print("Basis for K(S,2) = {}".format(KS2_basis))
    T2 = get_T2(K,S,verbose=False)
    print("T2 is as follows:")
    for I in T2:
        print("I = {}: P_I = {}".format(I,T2[I]))
    if allcurves:
        ncurves=nreds
        print("testing the {} reducible cases to see if the classes are small or large".format(nreds))
    else:
        ncurves=_sage_const_10 
        print("testing the first {} of {} reducible cases to see if the classes are small or large.   Run example1(allcurves=True) to see all of them.".format(ncurves,nreds))
    for lab in divpols["reducible"][:ncurves]:
        E = EllipticCurve(lab)
        print("{} has torsion order {}".format(lab,E.torsion_order()))
        BB = BlackBox_from_elliptic_curve(E)
        res = algo6(QQ,S,BB,T2)
        if res:
            print("Class {} is small, with discriminants {} (modulo squares)".format(lab,res))
            discs = Set(E2.discriminant().squarefree_part() for E2 in E.isogeny_class())
            print("Check: the curves in the isogeny class have discriminants with square-free parts {}".format(discs))
        else:
            print("Class {} is large".format(lab))

    print("\nExample 1 (continued) from page 31:")
    lab = '43808a'
    # Simulate the Black Box for this curve:
    BB = BlackBox_from_elliptic_curve(EllipticCurve(lab))
    ap = BB_trace(BB)
    BB_values = dict([(p,ap(p)) for p in T2.values()])
    print("Isogeny class {} has these ap for primes in T2: {}".format(lab,BB_values))

def example2(shortcut=True):
    print("\n"+"-"*_sage_const_80 )
    print("\nExample 2 from page 34:")
    x = polygen(QQ)
    K = NumberField(x**_sage_const_2 +_sage_const_1 ,'i')
    i = K.gen()
    N = K.ideal(_sage_const_56 +_sage_const_2 *i)
    S = Support(N)
    print("K = {}".format(K))
    print("S = {}".format(S))
    C3s = C3_extensions(K,S)
    print("For K = {} and S = {}, the C3 extension(s) of K unramified outside S are {}".format(K,S,C3s))
    # It takes about 4m to find 5 cubics, so here we allow a shortcut
    if shortcut:
        x = polygen(K)
        S3s = [x**_sage_const_3  + _sage_const_9 *x + _sage_const_918 *i - _sage_const_3348 ,
               x**_sage_const_3  + (_sage_const_132 *i - _sage_const_72 )*x + _sage_const_688 *i - _sage_const_3344 ,
               x**_sage_const_3  + _sage_const_12 *x - _sage_const_448 *i - _sage_const_432 ,
               x**_sage_const_3  + (_sage_const_9 *i + _sage_const_252 )*x + _sage_const_1512 *i - _sage_const_54 ,
               x**_sage_const_3  + (-_sage_const_9 *i + _sage_const_18 )*x - _sage_const_3067999686071442 *i + _sage_const_5303042246606904 ]
    else:
        S3s = S3_extensions(K,S)
    print("  and the S3 extension(s) of K unramified outside S are {}".format(S3s))
    F = C3s + S3s
    print("Hence we may take F = {}".format(F))
    flist, T0, vlist = get_T0(K,S,F)
    print("A distinguishing set for F is T0={}".format(T0))

    # To simulate the Black Box we use the elliptic curve 2.0.4.1-3140.3-c1
    E = EllipticCurve(K, [i + _sage_const_1 , -i + _sage_const_1 , _sage_const_0 , _sage_const_62 *i - _sage_const_22 , -_sage_const_192 *i - _sage_const_54 ])
    BB = BlackBox_from_elliptic_curve(E)
    ap = BB_trace(BB)
    # Check for reducibility of the residual representation:
    aps = [ap(P) for P in T0]
    print("The a_P for P in T0 are: {}".format(aps))
    assert all(a%_sage_const_2 ==_sage_const_0  for a in aps)
    print("All are 0 mod 2, so the mod-2 representation is reducible")

    # Find a quadratically independent set T2:
    T2 = get_T2(K,S, unit_first=False, verbose=False)
    print("T2 is as follows:")
    for I in T2:
        print("I = {}: P_I = {}".format(I,T2[I]))

    t1 = BB_t1(BB)
    t1_values = [t1(P) for P in T2.values()]
    assert all(t1==_sage_const_0  for t1 in t1_values)
    print("F_P(1) = 0 (mod 4) for all P in T2, so the class is large")
    Da, Db, Dc, Dabcd = algo63(K,S,BB,T2,unit_first=False)
    # print("Da = {}".format(Da))
    # print("Db = {}".format(Db))
    # print("Dc = {}".format(Dc))
    # print("Dabcd = {}".format(Dabcd))
    assert Db!=_sage_const_1  and Dc!=_sage_const_1  and Dabcd!=_sage_const_1 
    print("The isogeny graph has four vertices, and the extremal discriminants are {}, {}, {} (modulo squares)".format(Db,Dc,Dabcd))
    print("Check against the elliptic curves in isogeny class 2.0.4.1.3140-c:")
    c1 = EllipticCurve(K, [i + _sage_const_1 , -i + _sage_const_1 , _sage_const_0 , _sage_const_62 *i - _sage_const_22 , -_sage_const_192 *i - _sage_const_54 ])
    print("c1 ={} has discriminant {}".format(c1.ainvs(), c1.discriminant().factor()))
    c2 = EllipticCurve(K, [i + _sage_const_1 , -_sage_const_1 , _sage_const_0 , -_sage_const_48 *i + _sage_const_18 , _sage_const_30 *i - _sage_const_158 ])
    print("c2 ={} has discriminant {}".format(c2.ainvs(), c2.discriminant().factor()))
    c3 = EllipticCurve(K, [i + _sage_const_1 , -_sage_const_1 , _sage_const_0 , _sage_const_7 *i + _sage_const_8 , _sage_const_10 *i - _sage_const_18 ])
    print("c3 ={} has discriminant {}".format(c3.ainvs(), c3.discriminant().factor()))
    c4 = EllipticCurve(K, [_sage_const_0 , -i + _sage_const_1 , _sage_const_0 , -_sage_const_30 *i - _sage_const_36 , -_sage_const_102 *i - _sage_const_85 ])
    print("c4 ={} has discriminant {}".format(c4.ainvs(), c4.discriminant().factor()))


def example3(shortcut=True):
    print("\n"+"-"*_sage_const_80 )
    print("\nExample 3 from page 35:")
    x = polygen(QQ)
    K = NumberField(x**_sage_const_2 +_sage_const_1 ,'i')
    i = K.gen()
    N = K.ideal(_sage_const_10 +_sage_const_10 *i)
    S = Support(N)
    print("K = {}".format(K))
    print("S = {}".format(S))
    C3s = C3_extensions(K,S)
    print("For K = {} and S = {}, the C3 extension(s) of K unramified outside S are {}".format(K,S,C3s))
    # It takes about 11s to find one cubic, so here we allow a shortcut
    if shortcut:
        x = polygen(K)
        S3s = [x**_sage_const_3  - _sage_const_15 *x - _sage_const_70 *i]
    else:
        S3s = S3_extensions(K,S)
    print("  and the S3 extension(s) of K unramified outside S are {}".format(S3s))
    F = C3s + S3s
    print("Hence we may take F = {}".format(F))
    flist, T0, vlist = get_T0(K,S,F)
    print("A distinguishing set for F is T0={}".format(T0))

    # To simulate the Black Box we use the elliptic curve 2.0.4.1-200.2-a1 (which is isogenous to a base change of 40.a3/Q)
    E = EllipticCurve(K, [i + _sage_const_1 , i, i + _sage_const_1 , -_sage_const_31 *i - _sage_const_44 , _sage_const_94 *i + _sage_const_106 ])
    BB = BlackBox_from_elliptic_curve(E)
    ap = BB_trace(BB)
    # Check for reducibility of the residual representation:
    aps = [ap(P) for P in T0]
    print("The a_P for P in T0 are: {}".format(aps))
    assert all(a%_sage_const_2 ==_sage_const_0  for a in aps)
    print("All are 0 mod 2, so the mod-2 representation is reducible")

    # Find a quadratically independent set T2:
    T2 = get_T2(K,S, unit_first=True, verbose=False)
    print("T2 is as follows:")
    for I in T2:
        print("I = {}: P_I = {}".format(I,T2[I]))

    t1 = BB_t1(BB)
    t1_values = [t1(P) for P in T2.values()]
    assert all(t1==_sage_const_0  for t1 in t1_values)
    print("F_P(1) = 0 (mod 4) for all P in T2, so the class is large")
    Da, Db, Dc, Dabcd = algo63(K,S,BB,T2, unit_first=True, verbose=True)
    assert Da==_sage_const_1  and Db==_sage_const_1  and Dc==_sage_const_1  and Dabcd==_sage_const_1 
    print("The isogeny graph has more than four vertices, and the mod 4 representation is trivial")

    Da, Db, Dc, Dabcd = algo64(K,S,BB,T2, unit_first=True, verbose=True)
    assert Da!=_sage_const_1  and Db!=_sage_const_1  and Dabcd!=_sage_const_1  and Da!=_sage_const_1 
    print("Da = {}".format(Da))
    print("Db = {}".format(Db))
    print("Dc = {}".format(Dc))
    print("Dabcd = {}".format(Dabcd))
    print("The isogeny graph has 10 vertices, four inner ones of degree 3, and 3 pairs of extremal ones with discriminants {}, {}, {}".format(Db,Dc,Dabcd))
    print("The extra discriminant is {}".format(Da))
    print("The image of the mod 8 representation has order 16 and its kernel is the multiquadratic extension obtained by adjoining all four of these discriminants.")


